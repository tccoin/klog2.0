<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="klog-style-scrollbar.html">
<link rel="import" href="klog-image.html">
<link rel="import" href="klog-player-lite.html">
<link rel="import" href="klog-style-markdown.html">
<link rel="import" href="../static/lib/Han/han-style.html">
<dom-module id="klog-markdown">
  <template>
    <style include="klog-style-scrollbar"></style>
    <style include="klog-style-markdown"></style>
    <style include="han-style"></style>
    <article id="article" class="klog-article-content" theme$="[[theme]]">
      <slot></slot>
      <div id="content"></div>
      <slot name="after"></slot>
    </article>
  </template>
  <script src="../static/lib/Han/han.min.js"></script>
  <script src="../static/lib/marked/marked.min.js"></script>
  <script>
    class KlogMarkdown extends Polymer.Element {

      static get is() { return 'klog-markdown'; }

      static get properties() {
        return {
          markdown: {
            type: String,
            observer: '_render'
          },
          theme: {
            type: String,
            value: '',
            reflectToAttribute: true,
            observer: 'updateTheme'
          },
          hideIndependentTitle: {
            type: Boolean,
            value: false
          },
          collection: {
            type: String,
            notify: true
          },
          tags: {
            type: Array,
            notify: true
          },
          wordCount: {
            type: Number,
            notify: true
          },
          scrollBias: {
            type: Number
          },
          lazy: {
            type: Boolean,
            value: false
          },
          sanitize: {
            type: Boolean,
            value: true
          },
        }
      }

      updateTheme() {
        let elements = this.$.article.querySelectorAll('[theme]');
        for (let element of elements) {
          element.theme = this.theme;
        }
      }

      lazyInit() {
        if (!"IntersectionObserver" in window) {
          console.log('Lazy-load is not supported.');
          this.lazy = false;
        }
      }

      lazyObserve() {
        let lazyObserver = new IntersectionObserver((entries, observer) => {
          for (let entry of entries) {
            if (entry.isIntersecting) {
              let notlazy = entry.target;
              notlazy.lazyload();
              lazyObserver.unobserve(notlazy);
            }
          };
        });

        let lazyElements = this.$.article.querySelectorAll('[lazy]');
        for (let element of lazyElements) {
          lazyObserver.observe(element);
        }
      }

      ready() {
        super.ready();

        //lazy-init
        if (this.lazy) this.lazyInit();

        //render
        let renderer = new marked.Renderer();

        renderer.heading = (text, depth) => {
          let id = 'heading' + (++this._headingId);
          this._headings.push({ depth: depth, text: text, id: id });
          return `<h${depth} id="${id}" depth="${depth}">${text}</h${depth}>\n`;
        };

        renderer.image = (href, title, text) => {
          var out = '<klog-image src="' + href + '" alt="' + text + '"';
          if (title) {
            out += ' title="' + title + '"';
          }
          if (this.lazy) out += ` lazy theme="${this.theme}"`;
          out += '></klog-image>';
          if (text) {
            out = `<div image description>${out}<div class="description">${text}</div></div>`;
          } else {
            out = `<div image>${out}</div>`;
          }

          return out;
        };

        renderer.code = (code, lang, escaped) => {
          this.initCodeRenderer();
          let out = `<klog-render-code lang="${lang || ''}" code="${escape(code)}" theme="${this.theme}"></klog-render-code>\n`;
          return out
        };

        renderer.link = function (href, title, text = '') {
          if (/^&lt;V&gt;/.test(text)) {
            text = text.replace(/^&lt;V&gt;/, '');
            return `<a href="${href}">视频链接</a>`;
            //return `<klog-player-lite src="${href}" alt="${text}"></klog-player-lite>`;
          }
          var out = '<a href="' + href + '"';
          if (title) {
            out += ' title="' + title + '"';
          }
          out += '>' + text + '</a>';
          return out;
        };

        let block = {};

        block.toc = {
          reg: /^\n*\[toc\] *\n/i,
          lex: function (src, cap) {
            src = src.substring(cap[0].length);
            return { src: src, text: '' }
          },
          parse: () => {
            this._hasToc = true;
            return '{{KLOG-MARKDOWN-TOC}}'
          }
        };

        block.at = {
          reg: /^@\(([\s\S]*?)\)(\[([\s\S]*?)\])?/,
          lex: function (src, cap) {
            src = src.substring(cap[0].length);
            cap = [cap[1] ? marked.escape(cap[1]) : false, cap[3] ? marked.escape(cap[3]) : false];
            return { src: src, text: cap }
          },
          parse: (cap) => {
            this.collection = cap[0] || '';
            this.tags = cap[1] ? cap[1].toLowerCase().split(',') : [];
            return `<!--collection:${cap[0]};tags:${this.tags}-->`
          }
        };

        let inline = {};

        inline.katex = {
          reg: /^\$([^\$]+?)\$/,
          parse: (src, cap) => {
            this.initKatexRenderer();
            src = src.substring(cap[0].length);
            cap = marked.escape(cap[0].replace(/\$/gm, ''));
            return {
              src: src,
              text: `<klog-render-katex code="${cap}"><code lang="latex">${cap}</code></klog-render-katex>`
            };
          }
        };

        inline.katexblock = {
          reg: /^\$\$([^\$]+?)\$\$/,
          parse: (src, cap) => {
            this.initKatexRenderer();
            src = src.substring(cap[0].length);
            cap = marked.escape(cap[0].replace(/\$\$/gm, ''));
            return {
              src: src,
              text: `<klog-render-katex code="${cap}" block><code lang="latex">${cap}</code></klog-render-katex>`
            };
          }
        };

        let inlineText = /^[\s\S]+?(?=[\\<!\[`*\$~]|https?:\/\/|ftp:\/\/|www\.|[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}\$~-]+@|\b_| *\n|$)/;

        this.options = {
          gfm: true,
          tables: true,
          breaks: true,
          sanitize: this.sanitize,
          renderer: renderer,
          block: block,
          inline: inline,
          inlineText: inlineText
        };
      }

      _tocRenderer() {
        if (this._headings.length == 0) {
          this.isIndependentTitle = false;
          return '';
        }
        let headings = this._headings;
        let depth = 0;
        let bottom = 0;
        // determine lowest depth
        let h = Array.from(headings);
        h.sort((a, b) => a.depth - b.depth);
        this.isIndependentTitle = false;
        if (h.length == 1) {
          this.isIndependentTitle = true;
        } else if (h.length >= 2 && h[0].depth != h[1].depth) {
          // 如果最高级的heading只有一个，则它不应该出现在toc中
          this.isIndependentTitle = true;
          depth = headings[0].depth;
          bottom = depth;
          headings.splice(0, 1);
        }

        // output
        headings.push({ depth: depth });
        let out = '<div class="toc-icon-container"><iron-icon icon="bookmark" class="toc-icon"></iron-icon></div><div class="toc">';
        for (let heading of headings) {
          let newli = '';
          if (heading.depth < bottom + 3) {
            if (heading.text) newli = `<li name="${heading.id}" depth="${depth}"><span>${heading.text}</span>`;
            if (heading.depth == depth) {
              out += `</li>${newli}`;
            }
            while (heading.depth > depth) {
              ++depth;
              out += `<ol>${newli}`;
            }
            while (heading.depth < depth) {
              --depth;
              out += '</li></ol>';
              if (heading.text) out += `</li>${newli}`;
            }
          }
        }
        out += '</div>';
        return out
      }

      _tocEvent() {
        let links = this.$.content.querySelectorAll('div.toc li');
        for (let link of links) {
          link.addEventListener('mouseover', (e) => {
            e.stopPropagation();
            let _selected = this.$.content.querySelector('li.selected');
            if (_selected) _selected.classList.remove('selected');
            e.currentTarget.classList.add('selected');
          });
          link.addEventListener('click', (e) => {
            e.stopPropagation();
            let i = 0;
            while (e.currentTarget.tagName != 'LI') i++;
            let name = e.currentTarget.getAttribute('name');
            let element = this.$.content.querySelector('#' + name);
            if (element) {
              let bias = this.scrollBias || 0;
              let scrollTarget = this.scrollTarget || document.scrollingElement;
              //html will move while scrolling
              let htmlFix = scrollTarget.tagName == 'HTML' ? 0 : scrollTarget.getBoundingClientRect().top;
              let y = scrollTarget.scrollTop + element.getBoundingClientRect().top - htmlFix;
              this.scrollTarget.scrollTop = y;
            }
          });
        }
      }

      initKatexRenderer() {
        if (!this._isKatexInit) {
          Polymer.importHref(this.resolveUrl('klog-render-katex.html'));
          this._isKatexInit = true;
        }
      }

      initCodeRenderer() {
        if (!this._isCodeInit) {
          Polymer.importHref(this.resolveUrl('klog-render-code.html'));
          this._isCodeInit = true;
        }
      }

      _updateWordCount() {
        if (!this.$.content.innerText) {
          this.wordCount = 0;
          return;
        }
        this.wordCount = this.$.content.innerText
          .replace(/(\r\n+|\s+|　+)+/g, "龘")
          .replace(/[\x00-\xff]/g, "m")
          .replace(/m+/g, "*")
          .replace(/龘/g, "")
          .length;
      }

      _render() {
        // reset attributes
        this.$.content.innerHTML = '';
        this.collection = 'Daily';
        this.tags = [];
        this._headingId = 0;
        this._headings = [];
        this._hasToc = false;
        // no markdown
        if (!this.markdown) {
          this._updateWordCount();
          return;
        }
        // translate markdown
        marked(this.markdown, this.options, (err, out) => {
          if (err) throw err;
          //toc
          if (this._hasToc) {
            out = out.replace(/{{KLOG-MARKDOWN-TOC}}/g, this._tocRenderer());
            setTimeout(() => this._tocEvent(), 1);
          }
          //render
          this.$.content.innerHTML = out;
          // word count
          this._updateWordCount();
          // remove main title
          this._tocRenderer();
          if (this.isIndependentTitle && this.hideIndependentTitle) {
            let headings = Array.from(this.$.content.querySelectorAll('h1,h2,h3,h4,h5,h6'));
            headings.sort((a, b) => a.getAttribute('depth') - b.getAttribute('depth'));
            let title = headings[0];
            title.parentNode.removeChild(title);
          }
          //Han
          Han(this.$.article, this.$.article).render();
          setTimeout(() => this.dispatchEvent(new CustomEvent('markdown-rendered', { bubbles: true, composed: true })), 1);
          // lazy load image
          if (this.lazy) setTimeout(() => this.lazyObserve(), 1);
        });
      }

    }

    window.customElements.define(KlogMarkdown.is, KlogMarkdown);
  </script>

</dom-module>