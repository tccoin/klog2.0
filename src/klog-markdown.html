<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="klog-style-scrollbar.html">
<link rel="import" href="klog-image.html">
<link rel="import" href="klog-player-lite.html">
<link rel="import" href="klog-style-markdown.html">
<link rel="import" href="klog-data-user.html">
<link rel="import" href="../static/lib/Han/han-style.html">
<dom-module id="klog-markdown">
  <template>
    <style include="klog-style-scrollbar"></style>
    <style include="klog-style-markdown"></style>
    <style include="han-style"></style>
    <klog-data-user disabled id="user"></klog-data-user>
    <article id="article" class="klog-article-content" theme$="[[theme]]">
      <slot></slot>
      <div id="content"></div>
      <slot name="after"></slot>
    </article>
  </template>
  <script src="../static/lib/Han/han.min.js"></script>
  <script src="../static/lib/marked/marked.min.js"></script>
  <script>
    class KlogMarkdown extends Polymer.Element {

      static get is() { return 'klog-markdown'; }

      static get properties() {
        return {
          markdown: {
            type: String,
            observer: '_render'
          },
          theme: {
            type: String,
            value: '',
            reflectToAttribute: true,
            observer: 'updateTheme'
          },
          hideIndependentTitle: {
            type: Boolean,
            value: false
          },
          collection: {
            type: String,
            notify: true
          },
          tags: {
            type: Array,
            notify: true
          },
          wordCount: {
            type: Number,
            notify: true
          },
          scrollBias: {
            type: Number
          },
          lazy: {
            type: Boolean,
            value: false
          },
          sanitize: {
            type: Boolean,
            value: true
          },
          disabled: {
            type: Boolean,
            value: false
          },
          preference: {
            type: Object
          },
        }
      }

      updateTheme() {
        let elements = this.$.article.querySelectorAll('[theme]');
        for (let element of elements) {
          element.theme = this.theme;
        }
      }

      lazyInit() {
        if (!"IntersectionObserver" in window) {
          console.log('Lazy-load is not supported.');
          this.lazy = false;
        }
      }

      lazyObserve() {
        let lazyObserver = new IntersectionObserver((entries, observer) => {
          for (let entry of entries) {
            if (entry.isIntersecting) {
              let notlazy = entry.target;
              notlazy.lazyload();
              lazyObserver.unobserve(notlazy);
            }
          };
        });

        let lazyElements = this.$.article.querySelectorAll('[lazy]');
        for (let element of lazyElements) {
          lazyObserver.observe(element);
        }
      }

      ready() {
        super.ready();

        //lazy-init
        if (this.lazy) this.lazyInit();

        //render
        let renderer = new marked.Renderer();

        renderer.heading = (text, depth) => {
          let id = 'heading' + (++this._headingId);
          let classList = '';
          classList += this.preference.centeredHeading == 'true' ? 'centered-heading ' : '';
          classList += this.preference.numberedHeading == 'true' ? 'numbered-heading ' : '';
          classList = classList ? `class="${classList}" ` : '';
          this._headings.push({ depth: depth, text: text, id: id });
          return `<h${depth} ${classList} id="${id}" depth="${depth}">${text}</h${depth}>\n`;
        };

        renderer.image = (href, title, text) => {
          var out = '<klog-image src="' + href + '" alt="' + text + '"';
          if (title) {
            out += ' title="' + title + '"';
          }
          if (this.lazy) out += ` lazy theme="${this.theme}"`;
          out += '></klog-image>';
          if (text) {
            out = `<div image description>${out}<div class="description">${text}</div></div>`;
          } else {
            out = `<div image>${out}</div>`;
          }

          return out;
        };

        renderer.code = (code, lang, escaped) => {
          this.initCodeRenderer();
          let classList = '';
          classList += this.preference.overflowCode == 'true' ? 'overflow-code ' : '';
          classList += lang ? 'has-meta' : '';
          classList = classList ? `class="${classList}" ` : '';
          let out = `<klog-render-code ${classList} lang="${lang || ''}" code="${escape(code)}" theme="${this.theme}"></klog-render-code>\n`;
          return out
        };

        renderer.link = function (href, title, text = '') {
          if (/^&lt;V&gt;/.test(text)) {
            text = text.replace(/^&lt;V&gt;/, '');
            return `<a href="${href}">视频链接</a>`;
            //return `<klog-player-lite src="${href}" alt="${text}"></klog-player-lite>`;
          }
          var out = '<a href="' + href + '"';
          if (title) {
            out += ' title="' + title + '"';
          }
          out += '>' + text + '</a>';
          return out;
        };

        let block = {};

        block.toc = {
          reg: /^\n*\[toc\] *\n/i,
          lex: function (src, cap) {
            src = src.substring(cap[0].length);
            return { src: src, text: '' }
          },
          parse: () => {
            return '<div class="toc-icon-container"><iron-icon icon="bookmark" class="toc-icon"></iron-icon></div><div class="toc"></div>'
          }
        };

        block.at = {
          reg: /^@\(([\s\S]*?)\)(\[([\s\S]*?)\])?/,
          lex: function (src, cap) {
            src = src.substring(cap[0].length);
            cap = [cap[1] ? marked.escape(cap[1]) : false, cap[3] ? marked.escape(cap[3]) : false];
            return { src: src, text: cap }
          },
          parse: (cap) => {
            this.collection = cap[0] || '';
            this.tags = cap[1] ? cap[1].toLowerCase().split(',') : [];
            return `<!--collection:${cap[0]};tags:${this.tags}-->`
          }
        };

        let inline = {};

        inline.katex = {
          reg: /^\$([^\$]+?)\$/,
          parse: (src, cap) => {
            this.initKatexRenderer();
            src = src.substring(cap[0].length);
            cap = marked.escape(cap[0].replace(/\$/gm, ''));
            return {
              src: src,
              text: `<klog-render-katex code="${cap}"><code lang="latex">${cap}</code></klog-render-katex>`
            };
          }
        };

        inline.katexblock = {
          reg: /^\$\$([^\$]+?)\$\$/,
          parse: (src, cap) => {
            this.initKatexRenderer();
            src = src.substring(cap[0].length);
            cap = marked.escape(cap[0].replace(/\$\$/gm, ''));
            return {
              src: src,
              text: `<klog-render-katex code="${cap}" block><code lang="latex">${cap}</code></klog-render-katex>`
            };
          }
        };

        let inlineText = /^[\s\S]+?(?=[\\<!\[`*\$~]|https?:\/\/|ftp:\/\/|www\.|[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}\$~-]+@|\b_| *\n|$)/;

        this.options = {
          gfm: true,
          tables: true,
          breaks: true,
          sanitize: this.sanitize,
          renderer: renderer,
          block: block,
          inline: inline,
          inlineText: inlineText
        };
      }

      initKatexRenderer() {
        if (!this._isKatexInit) {
          Polymer.importHref(this.resolveUrl('klog-render-katex.html'));
          this._isKatexInit = true;
        }
      }

      initCodeRenderer() {
        if (!this._isCodeInit) {
          Polymer.importHref(this.resolveUrl('klog-render-code.html'));
          this._isCodeInit = true;
        }
      }

      _updateWordCount() {
        if (!this.$.content.innerText) {
          this.wordCount = 0;
          return;
        }
        this.wordCount = this.$.content.innerText
          .replace(/(\r\n+|\s+|　+)+/g, "龘")
          .replace(/[\x00-\xff]/g, "m")
          .replace(/m+/g, "*")
          .replace(/龘/g, "")
          .length;
      }

      _updateHeadings() {
        let headings = this._headings;

        // if there is no headings
        if (headings.length == 0) {
          this.hasIndependentTitle = false;
          return;
        }

        // determine independent title
        let sortedHeadings = Array.from(headings); //copy array fro sorting
        sortedHeadings.sort((a, b) => a.depth - b.depth);
        this.hasIndependentTitle = false;
        if (sortedHeadings.length == 1) {
          // 如果只有一个标题，则它是独立标题
          sortedHeadings[0].isIndependentTitle = true;
          this.hasIndependentTitle = true;
        } else if (sortedHeadings[0].depth != sortedHeadings[1].depth && sortedHeadings[0] === headings[0]) {
          // 如果第一个标题是唯一的最高级标题，则它是独立标题
          sortedHeadings[0].isIndependentTitle = true;
          this.hasIndependentTitle = true;
        }

        let numbers = [0, 0, 0, 0, 0, 0];
        let bottom = this.hasIndependentTitle ? sortedHeadings[0].depth + 1 : sortedHeadings[0].depth; // min of headings.depth

        // calculate number
        for (let heading of headings) {
          if (heading.isIndependentTitle) {
            heading.number = '';
            continue;
          }
          let depth = heading.depth - bottom;
          numbers[depth] += 1;
          for (let i = 0; i < 5 - depth; i++) {
            numbers[depth + 1 + i] = 0;
          }
          heading.number = numbers.slice(0, depth + 1).join('.') + '.';
        }

        // update heading elements
        for (let heading of headings) {
          let element = this.$.content.querySelector(`#${heading.id}`);
          if (heading.isIndependentTitle && this.hideIndependentTitle) {
            element.style.display = 'none';
            continue;
          }
          if (this.preference.numberedHeading == 'true') {
            let numberSpan = element.querySelector('.heading-number');
            if (numberSpan) { numberSpan.parentNode.removeChild(numberSpan) }
            element.innerHTML = `<span class="heading-number">${heading.number}</span> ${element.innerHTML}`;
          }
        }

        // update toc elements
        let tocs = this.$.content.querySelectorAll('.toc');
        let tocHTML = '';
        if (tocs.length > 0) {
          let depth = bottom, lastDepth = 0, outDepth = 0;
          for (let heading of headings) {
            let newli = '';
            if (!heading.isIndependentTitle && heading.depth - bottom < 3) {
              if (heading.text) newli = `<li name="${heading.id}" depth="${depth}"><span>${heading.number}  ${heading.text}</span>`;
              if (heading.depth == depth) {
                tocHTML += `</li>${newli}`;
              }
              while (heading.depth > depth) {
                ++depth;
                tocHTML += `<ol>${newli}`;
              }
              while (heading.depth < depth) {
                --depth;
                tocHTML += '</li></ol>';
                if (heading.text) tocHTML += `</li>${newli}`;
              }
            }
          }
          for (let toc of tocs) {
            toc.innerHTML = tocHTML;
          }
        }

        // set toc event
        let links = this.$.content.querySelectorAll('div.toc li');
        for (let link of links) {
          link.addEventListener('mouseover', (e) => {
            e.stopPropagation();
            let _selected = this.$.content.querySelector('li.selected');
            if (_selected) _selected.classList.remove('selected');
            e.currentTarget.classList.add('selected');
          });
          link.addEventListener('click', (e) => {
            e.stopPropagation();
            let i = 0;
            while (e.currentTarget.tagName != 'LI') i++;
            let name = e.currentTarget.getAttribute('name');
            let element = this.$.content.querySelector('#' + name);
            if (element) {
              let bias = this.scrollBias || 0;
              let scrollTarget = this.scrollTarget || document.scrollingElement;
              //html will move while scrolling
              let htmlFix = scrollTarget.tagName == 'HTML' ? 0 : scrollTarget.getBoundingClientRect().top;
              let y = scrollTarget.scrollTop + element.getBoundingClientRect().top - htmlFix;
              this.scrollTarget.scrollTop = y;
            }
          });
        }
      }
      _render() {
        if (!this.disabled) {
          this.render();
        }
      }

      render() {
        //load preference
        if (!this.preference) {
          this.preference = this.$.user.defaultMarkdownPreference;
        }
        // reset attributes
        this.$.content.innerHTML = '';
        this.collection = 'Daily';
        this.tags = [];
        this._headingId = 0;
        this._headings = [];
        // no markdown
        if (!this.markdown) {
          this._updateWordCount();
          return;
        }
        // translate markdown
        marked(this.markdown, this.options, (err, out) => {
          if (err) throw err;
          //render
          this.$.content.innerHTML = out;
          //update headings
          this._updateHeadings();
          // word count
          this._updateWordCount();
          //Han
          Han(this.$.article, this.$.article).render();
          setTimeout(() => this.dispatchEvent(new CustomEvent('markdown-rendered', { bubbles: true, composed: true })), 1);
          // lazy load image
          if (this.lazy) setTimeout(() => this.lazyObserve(), 1);
        });
      }

    }

    window.customElements.define(KlogMarkdown.is, KlogMarkdown);
  </script>

</dom-module>